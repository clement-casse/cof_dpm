//! Module that contains the protobuf encoding of all the terms of the model int protobuf
//! messages to be exchanged over the wire between multiple micro-services.
//!
//! This modules only defines `From<...>` or `TryFrom<...>` between the structures defined in
//! the [`crate::dice`] module and the code generated by Prost!, allowing to map elements if the
//! model into protobuf message and eventually protobuf messages into structs from the model.

use super::pb;
use super::{Dice, DiceSet, RolledDice, RolledDiceSet};

impl From<Dice> for pb::common::dice::v1::DiceType {
    fn from(value: Dice) -> Self {
        match value {
            Dice::D3 => Self::DiceType3,
            Dice::D4 => Self::DiceType4,
            Dice::D6 => Self::DiceType6,
            Dice::D8 => Self::DiceType8,
            Dice::D10 => Self::DiceType10,
            Dice::D12 => Self::DiceType12,
            Dice::D20 => Self::DiceType20,
            Dice::D100 => Self::DiceType100,
        }
    }
}

impl TryFrom<pb::common::dice::v1::DiceType> for Dice {
    type Error = super::Error;

    fn try_from(value: pb::common::dice::v1::DiceType) -> Result<Self, Self::Error> {
        match value {
            pb::common::dice::v1::DiceType::DiceType3 => Ok(Self::D3),
            pb::common::dice::v1::DiceType::DiceType4 => Ok(Self::D4),
            pb::common::dice::v1::DiceType::DiceType6 => Ok(Self::D6),
            pb::common::dice::v1::DiceType::DiceType8 => Ok(Self::D8),
            pb::common::dice::v1::DiceType::DiceType10 => Ok(Self::D10),
            pb::common::dice::v1::DiceType::DiceType12 => Ok(Self::D12),
            pb::common::dice::v1::DiceType::DiceType20 => Ok(Self::D20),
            pb::common::dice::v1::DiceType::DiceType100 => Ok(Self::D100),
            pb::common::dice::v1::DiceType::Unspecified => Err(Self::Error::UnspecifiedProtoEnum),
        }
    }
}

impl From<DiceSet> for Vec<pb::common::dice::v1::DiceType> {
    fn from(value: DiceSet) -> Self {
        value
            .0
            .into_iter()
            .map(pb::common::dice::v1::DiceType::from)
            .collect()
    }
}

impl TryFrom<Vec<pb::common::dice::v1::DiceType>> for DiceSet {
    type Error = super::Error;

    fn try_from(value: Vec<pb::common::dice::v1::DiceType>) -> Result<Self, Self::Error> {
        let encoded_dices = value
            .into_iter()
            .map(Dice::try_from)
            .collect::<Result<Vec<_>, _>>()?;

        Ok(Self(encoded_dices))
    }
}

impl From<RolledDice> for pb::common::dice::v1::RolledDice {
    fn from(value: RolledDice) -> Self {
        Self {
            dice: pb::common::dice::v1::DiceType::from(value.dice) as i32,
            result: value.result,
        }
    }
}

impl TryFrom<pb::common::dice::v1::RolledDice> for RolledDice {
    type Error = super::Error;

    fn try_from(value: pb::common::dice::v1::RolledDice) -> Result<Self, Self::Error> {
        let dice = Dice::try_from(value.dice())?;
        Ok(Self {
            dice,
            result: value.result,
        })
    }
}

impl From<RolledDiceSet> for Vec<pb::common::dice::v1::RolledDice> {
    fn from(value: RolledDiceSet) -> Self {
        value
            .0
            .into_iter()
            .map(pb::common::dice::v1::RolledDice::from)
            .collect()
    }
}

impl TryFrom<Vec<pb::common::dice::v1::RolledDice>> for RolledDiceSet {
    type Error = super::Error;

    fn try_from(value: Vec<pb::common::dice::v1::RolledDice>) -> Result<Self, Self::Error> {
        let encoded_rolled_dices = value
            .into_iter()
            .map(RolledDice::try_from)
            .collect::<Result<Vec<_>, _>>()?;

        Ok(Self(encoded_rolled_dices))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn can_encode_dice_protobuf() {
        let test_cases = &[
            (Dice::D3, pb::common::dice::v1::DiceType::DiceType3),
            (Dice::D4, pb::common::dice::v1::DiceType::DiceType4),
            (Dice::D6, pb::common::dice::v1::DiceType::DiceType6),
            (Dice::D8, pb::common::dice::v1::DiceType::DiceType8),
            (Dice::D10, pb::common::dice::v1::DiceType::DiceType10),
            (Dice::D12, pb::common::dice::v1::DiceType::DiceType12),
            (Dice::D20, pb::common::dice::v1::DiceType::DiceType20),
            (Dice::D100, pb::common::dice::v1::DiceType::DiceType100),
        ];

        for tc in test_cases {
            let proto_dice = pb::common::dice::v1::DiceType::from(tc.0);
            assert_eq!(proto_dice, tc.1);
        }
    }

    #[test]
    fn can_decode_dice_protobuf() {
        let test_cases = &[
            (pb::common::dice::v1::DiceType::DiceType3, Dice::D3),
            (pb::common::dice::v1::DiceType::DiceType4, Dice::D4),
            (pb::common::dice::v1::DiceType::DiceType6, Dice::D6),
            (pb::common::dice::v1::DiceType::DiceType8, Dice::D8),
            (pb::common::dice::v1::DiceType::DiceType10, Dice::D10),
            (pb::common::dice::v1::DiceType::DiceType12, Dice::D12),
            (pb::common::dice::v1::DiceType::DiceType20, Dice::D20),
            (pb::common::dice::v1::DiceType::DiceType100, Dice::D100),
        ];

        for tc in test_cases {
            let decoded_dice = Dice::try_from(tc.0).unwrap();
            assert_eq!(decoded_dice, tc.1);
        }

        let unspecified_dice = Dice::try_from(pb::common::dice::v1::DiceType::Unspecified);
        assert!(matches!(
            unspecified_dice,
            Err(crate::model::dice::Error::UnspecifiedProtoEnum)
        ));
    }

    #[test]
    fn can_encode_rolled_dice_protobuf() {
        let rolled_dice = Dice::D100.roll();
        let proto_rolled_dice = pb::common::dice::v1::RolledDice::from(rolled_dice);
        assert_eq!(
            proto_rolled_dice.dice(),
            pb::common::dice::v1::DiceType::DiceType100
        );
        assert_eq!(proto_rolled_dice.result, rolled_dice.result);
    }

    #[test]
    fn can_decode_rolled_dice_protobuf() {
        let proto_rolled_dice = pb::common::dice::v1::RolledDice {
            dice: pb::common::dice::v1::DiceType::DiceType20 as i32,
            result: 19u32,
        };

        let decoded_rolled_dice = RolledDice::try_from(proto_rolled_dice).unwrap();

        assert_eq!(decoded_rolled_dice.dice, Dice::D20);
        assert_eq!(decoded_rolled_dice.result, 19);
    }
}
